/**
 * Copyright 2013 DERI, National University of Ireland Galway.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package deri.uimr.ufstreamfeeder;

import deri.uimr.utilities.Logger;
import deri.uimr.utilities.mysql.BaseMySQLManager;

import java.sql.Connection;
import java.sql.Statement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Timestamp;
import java.sql.SQLException;

import java.util.Map;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

public class MySQLManager extends BaseMySQLManager {
    private final static FeederProperties properties = FeederProperties.getInstance();
    private final Map<Long,Long> messageTimestamps = new ConcurrentHashMap<Long,Long>();

    // No public instantiation, this is a singleton
    private MySQLManager() {
        super(properties.getMySQLHost(), properties.getMySQLPort(),
              properties.getMySQLUser(), properties.getMySQLPassword(),
              properties.getMySQLDBName());
    }

    // Singleton holder
    private static class SingletonHolder {
        public static final MySQLManager instance = new MySQLManager();
    }

    // Singleton instance getter
    public static MySQLManager getInstance() {
        return SingletonHolder.instance;
    }

    // Prepared statements queries
    private static enum PreparedStatements {
        TRUNCATE_COMMUNITIES("TRUNCATE `communities`"),
        TRUNCATE_CONVERSATIONS("TRUNCATE `conversations`"),
        TRUNCATE_MESSAGES("TRUNCATE `messages`"),
        TRUNCATE_REPLIES("TRUNCATE `replies`"),
        TRUNCATE_USERS("TRUNCATE `users`"),
        INSERT_COMMUNITY("INSERT IGNORE INTO `communities` (`id`,`title`) VALUES (?,?)"),
        INSERT_CONVERSATION("INSERT IGNORE INTO `conversations` (`id`,`community_id`) VALUES (?,?)"),
        INSERT_MESSAGE("INSERT IGNORE INTO `messages` (`id`,`user_id`,`conversation_id`,`subject`,`content`,`datetime`,`msgid`) VALUES (?,?,?,?,?,?,?)"),
        INSERT_REPLY("INSERT IGNORE INTO `replies` (`source_id`,`target_id`,`source_datetime`,`target_datetime`) VALUES (?,?,?,?)"),
        INSERT_USER("INSERT IGNORE INTO `users` (`id`,`email`) VALUES (?,?)");

        private final String query;
        PreparedStatements(final String query) { this.query = query; }
        public String query() { return query; }

        public PreparedStatement prepare(final Connection connection, final int autoGeneratedKeys) throws SQLException {
            return connection.prepareStatement(query, autoGeneratedKeys);
        }

        public PreparedStatement prepare(final Connection connection) throws SQLException {
            return prepare(connection, Statement.NO_GENERATED_KEYS);
        }
    }

    // Truncate all the database
    public boolean truncateAll() {
        Connection connection = null;
        try {
            connection = getConnection();
            connection.setAutoCommit(false);

            PreparedStatements.TRUNCATE_REPLIES.prepare(connection).executeUpdate();
            PreparedStatements.TRUNCATE_MESSAGES.prepare(connection).executeUpdate();
            PreparedStatements.TRUNCATE_CONVERSATIONS.prepare(connection).executeUpdate();
            PreparedStatements.TRUNCATE_COMMUNITIES.prepare(connection).executeUpdate();
            PreparedStatements.TRUNCATE_USERS.prepare(connection).executeUpdate();

            connection.commit();
            messageTimestamps.clear();
            return true;
        }
        catch( SQLException e ) {
            Logger.log("Error while truncating MySQL database: " + e.getMessage());
            return false;
        }
        finally {
            close(connection);
        }
    }

    // Insert a list of events into the database
    public long insertEvents(final List<Event> events) {
        Connection connection = null;
        try {
            connection = getConnection();
            connection.setAutoCommit(false);

            // Process each event
            long numCommitted = 0;
            for( final Event event : events )
                if( event.valid() ) {
                    // Insert user
                    {
                        final PreparedStatement st = PreparedStatements.INSERT_USER.prepare(connection);
                        st.setLong(1, event.user_id);
                        st.setString(2, String.format("%d@stream", event.user_id));
                        st.executeUpdate();
                    }

                    // Insert community
                    {
                        final PreparedStatement st = PreparedStatements.INSERT_COMMUNITY.prepare(connection);
                        st.setLong(1, event.community_id);
                        st.setString(2, String.format("Community %d", event.community_id));
                        st.executeUpdate();
                    }

                    // Insert conversation
                    {
                        final PreparedStatement st = PreparedStatements.INSERT_CONVERSATION.prepare(connection);
                        st.setLong(1, event.conversation_id);
                        st.setLong(2, event.community_id);
                        st.executeUpdate();
                    }
                    // Insert message
                    {
                        final PreparedStatement st = PreparedStatements.INSERT_MESSAGE.prepare(connection);
                        st.setLong(1, event.id);
                        st.setLong(2, event.user_id);
                        st.setLong(3, event.conversation_id);
                        st.setString(4, event.subject);
                        st.setString(5, event.content);
                        st.setTimestamp(6, new Timestamp(event.timestamp));
                        st.setString(7, event.msgid);
                        st.executeUpdate();
                        if( !messageTimestamps.containsKey(event.id) )
                            messageTimestamps.put(event.id, event.timestamp);
                    }

                    // Insert reply (if applicable)
                    if( event.reply_to != null && messageTimestamps.containsKey(event.reply_to) ) {
                        final PreparedStatement st = PreparedStatements.INSERT_REPLY.prepare(connection);
                        st.setLong(1, event.id);
                        st.setLong(2, event.reply_to);
                        st.setTimestamp(3, new Timestamp(event.timestamp));
                        st.setTimestamp(4, new Timestamp(messageTimestamps.get(event.reply_to)));
                        st.executeUpdate();
                    }

                    numCommitted++;
                } else Logger.log(String.format("Tried to insert an invalid event: %s", event));

            connection.commit();
            return numCommitted;
        }
        catch( SQLException e ) {
            Logger.log("Error while inserting events into MySQL database: " + e.getMessage());
            return 0;
        }
        finally {
            close(connection);
        }
    }
}
